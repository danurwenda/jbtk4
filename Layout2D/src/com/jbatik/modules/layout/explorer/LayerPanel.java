/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.jbatik.modules.layout.explorer;

import com.jbatik.core.api.CentralLookup;
import com.jbatik.core.api.GlobalUndoManager;
import com.jbatik.lsystem.api.editor.InvalidableVisualLSystemModel;
import com.jbatik.modules.layout.explorer.node.LayoutLayerNode;
import com.jbatik.modules.layout.explorer.view.PhotoshopOutlineView;
import com.jbatik.modules.layout.layering.LayoutLayer;
import com.jbatik.modules.layout.layering.SubLayoutLayer;
import com.jbatik.modules.layout.visual.LayoutScene;
import java.awt.BorderLayout;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.Set;
import javax.swing.ActionMap;
import javax.swing.text.DefaultEditorKit;
import org.openide.explorer.ExplorerManager;
import org.openide.explorer.ExplorerUtils;
import org.openide.util.Lookup;
import org.openide.util.lookup.Lookups;
import org.openide.util.lookup.ProxyLookup;

/**
 *
 * @author RAPID02
 */
public class LayerPanel extends javax.swing.JPanel implements ExplorerManager.Provider, Lookup.Provider {

    private final LayerController controller;

    public LayerPanel(LayerController con) {
        initComponents();
        //Create the OutlineView:
        PhotoshopOutlineView ov = new PhotoshopOutlineView("Layer");

        //Set the columns of the outline view,
        //using the name of the property
        //followed by the text to be displayed in the column header:
        ov.setPropertyColumns(
                LayoutLayer.LAYER_LOCKED_PROP, "Locked",
                LayoutLayer.LAYER_MAPPABLE_PROP, "Mappable"
        );

        //disable sort on all visible columns
        ov.setTreeSortable(false);
        ov.setPropertyColumnAttribute(LayoutLayer.LAYER_LOCKED_PROP, "SortableColumn", Boolean.FALSE);
        ov.setPropertyColumnAttribute(LayoutLayer.LAYER_MAPPABLE_PROP, "SortableColumn", Boolean.FALSE);

        //hide root node, that is, the node that contains all first level layer
//        ov.getOutline().setRootVisible(false);
        controller = con;
        //set em first before adding ov
        em = controller.getExplorerManager();

        //Add the OutlineView to the TopComponent:
        add(ov, BorderLayout.CENTER);

//        em.setRootContext(controller.getRootNode());
        //init lookup
        ActionMap map = new ActionMap();
        map.put(DefaultEditorKit.copyAction, ExplorerUtils.actionCopy(em));
        map.put(DefaultEditorKit.pasteAction, ExplorerUtils.actionPaste(em));
        map.put("delete", ExplorerUtils.actionDelete(em, false));//"delete" here is actually DeleteAction.getActionMapKey()
        dum = new ModelInjector(em);
        lookup = new ProxyLookup(ExplorerUtils.createLookup(em, map), Lookups.singleton(con));
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setLayout(new java.awt.BorderLayout());
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    ExplorerManager em;

    @Override
    public ExplorerManager getExplorerManager() {
        return em;
    }

    private Lookup lookup;

    @Override
    public Lookup getLookup() {
//        System.err.println("panel lookup");
        return lookup;
    }
    ModelInjector dum;

    @Override
    public void removeNotify() {
        super.removeNotify();
        dum.stopListening();
    }

    @Override
    public void addNotify() {
        super.addNotify();
        dum.update();
        dum.startListening();
    }

    /**
     * This class injects InvalidableVisualLSystemModel into CentralLookup based
     * on ExplorerManager's selected nodes.
     */
    private class ModelInjector implements PropertyChangeListener {

        ExplorerManager manager;

        private ModelInjector(ExplorerManager em) {
            this.manager = em;
        }

        public void startListening() {
            manager.addPropertyChangeListener(this);
        }

        public void stopListening() {
            manager.removePropertyChangeListener(this);
        }

        @Override
        public void propertyChange(PropertyChangeEvent evt) {
            if (evt.getPropertyName().equals(ExplorerManager.PROP_SELECTED_NODES)) {
                update();
            }
        }

        void update() {
            Set<LayoutLayer> s = LayoutLayerNode.nodesToSet(manager.getSelectedNodes());
            InvalidableVisualLSystemModel mod = CentralLookup.getDefault().lookup(InvalidableVisualLSystemModel.class);
            //clearing previous, if any
            if (mod != null) {
                CentralLookup.getDefault().remove(mod);
            }
            //add if only 1
            if (s.size() == 1) {
                LayoutLayer layer = s.iterator().next();
                if (layer instanceof SubLayoutLayer) {
                    SubLayoutLayer sll = (SubLayoutLayer) layer;
                    CentralLookup.getDefault().add(new InvalidableVisualLSystemModel(sll.getSublayout(), GlobalUndoManager.getManager()) {

                        @Override
                        public void addSavable() {
                            if (controller.scene instanceof LayoutScene) {
                                LayoutScene layoutScene = (LayoutScene) controller.scene;
                                layoutScene.addSavable();
                            }
                        }
                    });
                }
            }
        }
    }

}
